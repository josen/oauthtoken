# 1.  问题定义

【帮助1】详细设计通常是承接上一级设计拆解的组件需求，首先应该指出需求来自哪里，确保与不遗漏，要能承上启下，先概述，再进入需求分析

【帮助2】聚焦于问题：明确要做什么、做到什么程度、为什么要做这些事

【帮助3】本章节是评审者关注的关键章节，要做到如下几点：

*   上级评审者：确认你的理解和它的理解是一致的
*   测试人员：知道实现哪些功能、如何验证/验收、如何设计用例
*   （可选）下一级：如果由他人参与编码，需要能让他人看得懂

【建议】用自己的语言重述业务场景、范围、功能和质量目标，不要直接摘抄上级总体设计和SRS，通过自己的思考可以更深入的理解问题，与上级、平级开发人员达成一致。

## 1.1 背景介绍

【裁剪说明】不可裁剪
【帮助】一两句简单的话介绍本任务的背景, 使得读者理解本设计的背景，定性的了解文档范围
【示例1】本文档描述通用分布式缓存中间件（Redis）的设计，事业部中多个解决方案或子系统（RCDC\RCCP\UWS\CMR\CMS）均可选用此CBB来加速开发。
【示例2】本文档描述VDI桌面池的设计，课堂和办公产品可复用桌面池能力包装出呼叫中心、计算机机房等解决方案。

## 1.3 系统上下文

【裁剪说明】可裁剪
【建议】直接引用上级文档的结构视图。
【帮助】通过软件结构视图，描述本模块与周边模块的关系，将系统上下文描述清楚，确定本设计边界

## 1.4 需求分析

### 1.4.1 功能需求

【裁剪说明1】对于详细设计或简单设计，如果SRS已明确需求规格和质量规格，本章节可裁剪。
【裁剪说明2】对于二合一、三合一设计本章不可裁剪
【帮助1】软件解决的是“人”的问题，所有分析将用户放在首位，用户有课堂、办公用户、渠道用户、400、LMT
【帮助2】根据问题三要素：用户（谁）、场景（在什么情况下/遇到了什么问题）、期望（期望得到什么样的效果/期望如何解决问题）来进行问题描述与澄清；
【帮助3】需求导入方包含：用户需求、系统需求、组件功能需求和子组件功能需求；
【帮助4】各类需求对应的工程化方法
1）用户需求，通过用例/场景、用户故事等方法来进行需求分析
2）系统需求，通过上下文视图、交互视图、结构视图、行为视图等方法来进行系统分析
3）子/组件功能需求通过结构、行为等方法来进行软件设计
【示例1】可维护性专项-概要设计V1.0 参考第一章
【实例2】脑图方式的问题定义

### 1.4.2 质量需求（非功能需求）

【裁剪说明】不可裁剪（即使有上级文档也不可裁剪，需要梳理分析或摘抄）
【建议】摘抄上级文档中质量需求并补充缺漏
【帮助1】本章节的理论基础来自于GB∕T 25000.10-2016 系统与软件工程 系统与软件质量要求和评价(SQuaRE) 第10部分：系统与软件质量模型.pdf
【帮助2】本章节应当描述每种质量事件产生后的预期效果（外部可见的效果），而非具体的实现原理
【帮助3】质量属性分为运行期和开发期

*   运行期主要是针对客户使用软件的一些质量保障，即没有这些质量保障将无法正常使用，典型的是性能、容量、可靠性、安全性
*   开发期主要是针对开发人员当前、未来对于软件的修改和维护，典型的是可维护性
*   运行期和开发期均需要考虑易用性，运行期的易用性主要针对UI和操作体验、开发期主要针对API的易用性

| 指标      | 关注内容                                                                                                                                                                                                                                                  | 产生的事件                                                                                                                                                        | 期望的效果                                                                                                                                                     |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 可靠性/可用性 | 系统的故障影响范围和恢复时间指标                                                                                                                                                                                                                                      | 环境不可靠导致的故障掉电、断网、进程被杀故障产生后的影响范围和恢复时间依赖不可靠导致的故障数据库故障导致的故障范围和恢复时间自研依赖组件故障导致的故障范围和恢复时间                                                                           | 环境问题自恢复 例如：集群环境5分钟内完成切换、进程被杀后1分钟内恢复依赖问题自恢复- 依赖组件故障后影响的业务（例如仅影响新接入用户）依赖组件恢复后自身业务的恢复时长（几秒或几分钟后恢复）                                                           |
| 可修改性    | 可修改性在GB∕T25000.10-2016中属于“维护性”的子属性，指系统或软件的能够快速地以较高的性价比对系统进行变更的能力可修改性面向未来，模块开发完成后可修改性就固定了当模块发生修订（功能扩展、修改BUG）时花费的代价（包括但不限于关联模块的改动、模块内部的改动、测试的工作量和范围），代价越小表示可修改性越高识别可能的变化，新增功能或者修改原有功能产生的影响，从依赖及被依赖的组件变化带来的影响角度识别变化；可能引出新的功能特性；重点考虑开发下个版本需要支持的特性需要预留哪些扩展 | 编写文档时反复思考某个被认为不可修改的功能是否真的没有修改的场景、变更某些参数的代价是否会非常大，参考：改变某个功能、行为（明确未来可预见）明显的业务扩展改变某个参数：例如磁盘大小使用规模发生变更：例如桌面数从100变更到10000新版本升级平台的变更（Linux到Windows）替换某个开源组件进行BUG修订 | 修订不影响无关的功能，有办法快速验证修订的正确性和关联影响软件的新增和修改功能可以通过API、配合LOG、内部数据等方式快速验证修复效果软件本身必须升级功能、升级的代价可控（从旧版本升级到当前版本）软件补丁包以模块或更细粒度的方式执行故障修复软件修改后的重启时间在客户容忍范围内，或者做到不间断业务的热升级 |
| 易用性     | 可理解性、易学习性、易操作性重点考虑使用者可感知的，对外暴露接口易用性，页面交互的易用性                                                                                                                                                                                                          | 用户通过系统实现某个业务目标上层开发者通过调用API的方式实现业务目标                                                                                                                          | 一个界面能搞定的配置，就用一个界面在满足可修改性要求的前提下，配置参数越少越好、API越少越好尽量少引入新的名词、概念，有业界标准的名词和概念就沿用业界标准的遵循“最小惊讶”原则                                                                 |
| 安全性     | 保证系统访问和数据的安全                                                                                                                                                                                                                                          | 安全红线的需求对于用户数据删除、覆盖的操作                                                                                                                                        | 满足安全红线用户个人数据清理、删除需要二次确认                                                                                                                                   |
| 可测试性    | 软件新增、修订的功能需要通过较小的代价进行验证，而不是需要全部重测软件满足可观察、可控制、可追踪、可理解四个特性时认为满足可测试性                                                                                                                                                                                     | 软件发生修改后如何证明修改的正确性测试人员对软件提出的要求，包括合理的控制参数、日志中关键数据的输出                                                                                                           | 软件内部状态的记录和暴露，例如LOG记录、关键配置参数等LOG等数据可以方便的收集，通过LOG内容可定位故障、观察输出信息验证码等内部数据通过LOG、内部API的方式暴露                                                                     |

【帮助3】

*   性能容量需求推导，一般从上级的设计中导入或者是从需求映射表中导入，分别从以下维度来推导：
    *   资源使用率：CPU、内存、磁盘（IO）、网络（IO），根据通常经验建议占用率在80%以下
    *   处理时间：响应时间（RT）、单位时间的请求数（QPS）
    *   业务成功率：
        *   并发量为M时，响应成功率为N%
*   性能容量指标不能凭空想，要从业务场景出发，每个指标要有依据，即“测试按照这个指标验收通过后，系统是可以满足已预设场景的需要”
*   对于大型系统来说，只有关键场景需要详细的性能和容量指标推导，例如：云桌面领域开机速度、桌面容量就是关键指标
*   同一个模块不同功能的性能需求不一定完全一致，例如：在办公场景下，云桌面创建的性能指标通常会强于云桌面删除，原因是云桌面删除动作触发的机会比创建少，场景也有差异。

### 1.4.3 软件约束

【裁剪说明】二合一设计不可裁剪（如果上级设计中已明确定量描述对本模块的约束，则直接摘抄或引用）
【帮助1】GB∕T 25000.10-2016的质量属性中并没有独立“软件约束”这个名词，部分内容与国标文档中的“依从性”、“兼容性”有关；在我们的场景中本章节中的要求通常以明确的需求指标的方式体现，独立拆分有利于工程师进行针对性的设计考虑
【帮助2】约束包括运行环境（支持的OS、支持的浏览器、CPU架构）、部署方法（独立进程方式运行、合并到其他进程中运行）、资源占用（CPU、内存、磁盘、网络可用上限）的约束
【帮助3】需要定量的描述约束，例如：OS需要明确支持哪些版本
【帮助4】资源占用标识模块可用的资源上限，与容量章节的描述有差异，容量章节体现系统正常运行（含可预见的压力）情况下的资源需求，资源上限体现系统在任何压力情况下都不能超过的上限，例如：当内存占用率超过2GB，docker的OOM Killer会执行进程强杀
【帮助5】如果软件涉及新增开源组件的引入，需要明确哪些开源协议的软件可用
【帮助6】如果软件涉及海外销售，需要遵循属地的合规政策（知识产权、用户隐私）

## 1.5 需求归纳

【裁剪说明】不可裁剪，建议摘抄或截图SRS或上级总体设计第三章的对应内容
【帮助1】对需求分析章节导出的软件需求的汇总，参考下述表格汇总需求。需求序号，用于跟踪及确认需求是否被完整实现
【帮助2】每个功能有对应的质量要求需要明确写出

| 序号  | 一级规格     | 二级规格  | 描述                                         |
| --- | -------- | ----- | ------------------------------------------ |
| 1.1 | VDI桌面池管理 | 添加桌面池 | 功能支持单条添加和批量添加质量最大支持20个桌面池同时创建单个桌面池创建时长小于5秒 |

# 2. 设计考虑

## 2.1 功能属性设计

【裁剪说明】不可裁剪
【帮助】

*   全面考虑“功能特性设计”和“质量特性设计”，需要完全涵盖第一章的所有功能需求和质量需求。
*   通常本章节深入思考后可能会修订第一章的部分内容
*   设计和开发不是重复造轮子，通用技术和通用业务请先参考云桌面事业部-技术CBB看板

### 2.1.1 功能1

【裁剪说明】不可裁剪
【帮助1】

*   描述软件设计的逻辑。讲解主要的因素，以及设计软件结构时考虑的设计目的、用户接口。
*   如果是对现有产品的代码进行完全重写，需要说明为什么现有的代码不符合需求。
*   如果是对现有模块的代码进行扩展，需要考虑已有逻辑的复用，常见的复用方式包括：抽取公共流程、抽取公共子方法（函数）、利用策略模式分离差异逻辑
*   如果在设计中产生了通用方法、函数，需要可以在同类型场景下复用
*   评估该功能的复杂性以及与其它软件功能点的交互关系。
*   除按已有的标准、规范或创新自主的标准与规范进行功能设计实现的考虑外，还应评估是否有受影响的功能模块，比如：是否还有其他功能或模块会操作与控制与本设计所涉及的相同的资源，相互间如何进行相容设计。
    【帮助2】功能属性的设计需要考虑旧版本是否能正常升级到新版本、业务流程变更对于依赖组件的影响
    【帮助3】方案选型（纯详细设计或简单设计不涉及方案选型）
    对于设计决策有重大影响的核心方案选型，需使用方案决策要素表进行方案比对并给出方案选型的结论。
    方案决策要素表说明，标准优先级与权重的确定，主要受四个要素的影响：产品需求、组织目标、技术条件与组织能力。评分建议：0，不满足；5：满足；10：有优势。

| 评审维度 | 指标     | 方案1XXX | 方案1说明 | 方案1评分 | 方案2XXX | 方案2说明 | 方案2评分 |
| ---- | ------ | ------ | ----- | ----- | ------ | ----- | ----- |
| 非功能  | 性能     |        |       |       |        |       |       |
| 非功能  | 容量     |        |       |       |        |       |       |
| 非功能  | 可用性    |        |       |       |        |       |       |
| 非功能  | 可修改性   |        |       |       |        |       |       |
| 非功能  | 易用性    |        |       |       |        |       |       |
| 非功能  | 可测试性   |        |       |       |        |       |       |
| 非功能  | 安全性    |        |       |       |        |       |       |
| 开发难度 | 开发难度   |        |       |       |        |       |       |
| 工作量  | 工作量    |        |       |       |        |       |       |
| 决策结论 | 最终选择方案 |        |       |       |        |       |       |
| 决策结论 | 选择方案理由 |        |       |       |        |       |       |

【帮助4】变更影响盘点

*   A和B两个模块有依赖（B依赖A），那么A模块的特性变更大概率影响B的行为，需要进行变更分析
*   A为整个系统中的某个子系统，A对于外部资源的需求变更（CPU、内存、磁盘）会对整个系统产生影响，需要进行变更分析。常见资源影响较大的功能：
    *   大文件的MD5计算：耗费大量CPU、IO

## 2.2 质量属性设计

【裁剪说明】不可裁剪。某个章节如果不涉及，明确写出不涉及的理由
【帮助】
描述使用什么样的方式达成质量特性的设计目标

*   什么样的结构能达到性能、可用性目标
*   需要预留哪些配置、或接口支持有效的软件测试的软件接口。
*   包括当错误发生时，能在内存中保留信息或者提供跟踪手段，以及相应的调试考虑（比如debug命令以及选项等）。

### 2.2.1 可靠性/可用性设计

【帮助1】首次编写本章节，请阅读：可靠性/可用性设计指南
【帮助2】依赖可靠性
根据组件视图分析当前组件（模块）对哪些其他组件（模块）产生依赖，依赖组件故障后当前组件能否识别和恢复
请参照下表完成依赖和对策分析
【帮助3】环境可靠性
环境问题包括掉电、进程被杀、磁盘满、内存不足等外部因素导致的问题。
请参照下表完成问题和对策分析

### 2.2.2 性能和容量设计

【帮助】性能设计

*   本节关注如何有效地达到性能指标, 比如开机速度要求在10秒内开机这个性能指标如何设计实现。容量指标通常会涉及相关数据结构的设计实现考虑和性能也相关。
*   影响性能的主要因素
    *   【提示一】算法的效率：如大表查询/遍历对性能的影响，数据产消模型的处理与调度策略，查找算法中，线性表的效率是O(n)，而树的效率是O(lgn)；
    *   【提示二】软件构成：如模块封装与性能需要平衡，多次跨越模块边界的处理时间开销较大；
    *   【提示三】对计算资源的利用：线/进程优先级对性能的影响，如在多CPU运行环境中的多线程运行方式，能够有效用计算资源。
        【帮助2】容量设计
*   容量设计主要考虑内存、磁盘、网络IO的容量
*   LOG、审计日志、临时文件
    *   容量需要定义上限
    *   建议LOG滚动输出
*   常见内存和磁盘容量计算建议
    *   数据库存储的数据通常进行过内部转码或简单压缩，基于表中行的数据类型进行计算时误差通常会很大，建议实测
    *   Java等高级编程语言中的对象、结构体等数据在内存中的表达不一定与实际一致，理论误差通常会偏大，建议实测
    *   如果使用SSL能力（包括TCP TLS、HTTPS）等，不要遗漏SSL上下文占据的内存空间，经过实测Java 8中每个SSL连接会占用约30KB的内存，并且无技术手段进行优化
    *   【帮助3】典型故障案例
*   LOG、审计日志等内容需要定义容量上限，计算该上限的最大数据容量，并提供定时清理的能力
*   特别注意引入开源组件时，开源组件自身的LOG需要重定向到统一LOG目录、并限定LOG大小
*   开源中间件使用中需要限制内存
*   处理大批量数据时，需要控制并发数
*   处理网络请求时，对外暴露端口的连接数需要根据请求数来计算

### 2.2.3 升级和兼容性设计

【裁剪说明】不可裁剪
【帮助1】跨OS/CPU指令集的兼容性设计

*   客户端软件、云桌面代理、RainOS通常需要支持多系统和多CPU指令集，
    *   多系统包括：
        *   Windows（多系列）
        *   国产类Linux系统：KOS/UOS
        *   标准Linux（Ubantu/Debain）
        *   MacOS
        *   移动端（Android、IOS、鸿蒙）
    *   多CPU指令集包括：ARM、x86、MIPS、loongarch
*   注意事项
    *   使用QT不代表兼容，需要实测（尤其是近两三个小版本新引入的特性）
    *   依赖OS的原生API、路径需要独立划分模块封装
    *   X11、Xwayland、Wayland等图形框架容易出现兼容性问题，需要实测
    *   第三方依赖库会产生级联依赖的问题，这些级联依赖可能与OS原有库版本冲突，解法二选一：
        *   引入/静态编译所有级联依赖
        *   【优选】全部使用OS原始版本
    *   除了考虑代码的兼容性之外，还需要需要设计不同OS/指令集的安装、升级、编译和打包
    *   集成测试时需要考虑跨OS/CPU指令集的环境搭建
        【帮助2】新旧版本兼容性（可升级）
*   已有API的变化，要求尽量兼容
    *   如果有接口删除或变更：与SE及依赖API的专业组沟通一同更改，文档中截图沟通记录
    *   可以同时保留新旧两套接口，与依赖API的专业组沟通进行接口切换
*   数据结构的变化，需要有兼容性升级的方案
*   对于版本升级的考虑设计，包含本地升级、在线升级，升级失败的回滚
*   升级设计考虑包含，版本升级路径考虑，能否支持跨多个版本的升级，升级时数据如何升级，包含数据库数据、文件数据、镜像、桌面数据等等
*   对于运行在终端上的组件，需要同时考虑几种场景，如新旧终端、新旧服务器排列组合的几种场景
*   对于全新的组件要评估是否会影响未来版本的升级，对于开源组件考虑开源组件是否能升级，升级失败是否可以正常回滚

### 2.2.4 可修改性设计

【帮助1】可扩展性

*   常见的扩展
    *   引入同类型的新功能
        *   RCDC支持VMWare作为IaaS
        *   虚机目前支持1块数据盘，未来可能支持多块数据盘
    *   关键器件升级（硬件B配套）
    *   外部环境变化
        *   以前支持Linux，现在需要支持Windows
        *   以前是8080端口，现在需要使用8081端口
    *   关联模块或组件变化
        *   不可控的外部组件变化，例如OS接口变化
        *   CPU、内存、磁盘更换
    *   性能和容量指标变化
*   常见设计方法：
    *   组件化、模块化方法，通过API隔离接口和实现
    *   通过策略模式在不变更主体业务的情况下增加新功能
    *   为使用者提供配置参数
        【帮助2】可伸缩性
        应用系统应对未来容量增长有两种设计方式：
*   水平扩容：支持多节点负载均衡方式部署，需要考虑节点无状态、分布式存储问题
*   垂直扩容：通过增加CPU、内存、磁盘的方式扩容，受限于单个任务的并发度
*

### 2.2.5 易用性设计

| 易用性问题                                                                                 | 常见的解决方案                     | 解决方案带来的次生问题              |
| ------------------------------------------------------------------------------------- | --------------------------- | ------------------------ |
| 些对用户使用的限制与约束，除了写在产品相关手册上以外，能否通过系统软件的实现，防止用户掉入“陷阱”，帮助用户完成其想完成的任务可能的话，对用户的错误操作，如何降低负面影响 | 页面中增加提示、禁用或启用某些功能           | 页面交互变复杂，可能的故障点变多，需要梳理页面流 |
| 对于需要较长时间才能完成的操作，如何让用户确信，用户的操作正在被忠实的执行中                                                | 将任务拆分成多个可见的步骤，每个步骤状态变更后通知用户 | 页面交互变复杂，可能的故障点变多，需要梳理页面流 |

### 2.2.6 安全性设计

【帮助1】基本要求满足安全红线云桌面安全红线通用检查表 漏洞自查表\_云桌面事业部
【帮助2】考虑如何抗攻击；检测、识别与记录攻击；

*   几种特定的攻击方式：WEB的XSS、CSRF攻击、ip欺骗、tcp劫持、shell注入
*   开源引入要对比寻找安全性高的版本（不一定最新版本）
    【帮助3】数据安全
*   所有删除用户的私人数据（删除文件、格式化磁盘）的动作都需要用户确认，要有确认日志记录。
*   对管理员的关键高危操作要有日志记录（比如清除用户数据，修改配置等）。
    【帮助4】参考如下文档（文档持续完善中）常见漏洞分析与解决
    【帮助5】并发和同步安全设计最佳实践

### 2.2.7 可测试性设计

【帮助1】可测试性包括可观察、可控制、可追踪、可理解四个特性。
【设计提示】

| 分类  | 设计指导                                                                                                                                                                                                                                   |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 可观察 |                                                                                                                                                                                                                                        |
|     | 可追踪                                                                                                                                                                                                                                    |
| 可理解 | 内部行为可观察增加输出参数和错误种类记录必要的LOG信息，尤其当系统出现异常时，需要打印导致异常的所有信息与其他组件（尤其是第三方）交互控制信息时，需要打印所有请求参和应答参数分布式软件当组件间的通信通断、重连时，需要记录LOG内部行为可追踪记录内部状态信息、统计信息日志统一、分级存储，可以一键收集通过调用链、metric等工具进行跟踪日志信息可理解只在国内市场销售的服务端软件的LOG以中文方式打印客户端软件、可能在海外市场销售的软件的LOG以英文方式打印 |
| 可控制 | 为单元测试提供便利性支持，例如：模块化设计和开发外部依赖边界清晰可Mock通过配置等方式控制软件行为，为自动化测试提供帮助，例如：提供验证码读取的能力提供定时任务执行周期的控制                                                                                                                                               |

## 2.3 软件约束设计

### 2.3.1 运行环境和资源约束

【帮助1】资源约束：描述软件达到资源上限时的行为（包含被强杀时的行为）
【帮助2】运行环境：描述软件在不同OS、不同浏览器运行的差异
【帮助3】如果大多数描述已包含在前文中，本章节可裁剪

### 2.3.2 知识产权合规约束

【帮助1】知识产权合规主要来自海外销售的属地要求，通常由法务给出，目前能收集到的实践包括：

*   开源协议是否可用（尤其是GPL体系的开源协议）
*   接口数据是否涉及公网交互（公网交互-需要输出隐私协议和用户协议，需要更新用户协议，隐私协议）
*   收集数据是否涉及用户隐私信息（比如：姓名，设备Ip,设备mac，需要更新用户协议，隐私协议）
*   jar包引用（比如jdk 中 oracle 商用密码算法，需引入的jar包，采用那些开源协议）
*   算法引用-是否来自第三方专利
*   详细设计创意是否是已有专利
*   方案中是否涉及cookie存储

# 3. 主要结构

## 3.1 组件视图

【帮助1】描述系统的模块构成、模块内部结构，依赖关系等，以类图、包图、模块关系图的方式呈现，颜色请遵循下面的图例：
\[图片]
【帮助2】对于组件视图的要求：

*   北向对外提供能力、南向使用外部能力
*   涵盖用例视图中的所有功能
*   模块内高内聚
*   以图文结合的方式进行描述，每个图包含对应的说明信息（组件的名称、核心职责、与其他组件的关系、对外暴露基本能力）
    【裁剪说明】简单设计和详细设计可裁剪，其余不可裁剪

## 3.2 部署视图

【帮助1】以物理部署的视角描述系统部署架构，需体现出系统运行的环境，包含但不限于以下内容，运行的物理主机，容器如Docker容器，Web服务器。可在部署图上体现组件之间的依赖关系。
【帮助2】若有多种部署形态，需将每一种部署形态都呈现出来。
【帮助3】部署视图的要点：

*   编译输出物需要与组件视图中的模块划分对应，各输出物之间遵循单向依赖原则
*   明确最终部署环境的目录结构、各编译输出物所在的路径
*   系统以单进程还是多进程的方式运行
    【裁剪说明】详细设计和简单设计可裁剪，二合一、三合一设计不可裁剪

### 3.3 开发视图

【帮助1】描述系统的代码组织形式、工程结构、工程间的关系、目录规划、核心类结构。
【帮助2】开发视图要点：

*   源码的工程结构、内部目录结构或包结构的划分是与组件视图中的模块划分对应，遵循单向依赖原则
*   核心类（对象）使用对应领域的语言进行命名，例如：
    *   在桌管领域，应当使用桌面来命名核心对象，而非虚机
    *   虚机本质是运行在KVM体系下的Qemu进程，在云管领域以虚机来命名，而非使用“进程”这个名词
*   核心类（对象）之间的依赖关系不存在无用依赖，符合上层依赖下层的原则
    *   下层稳定，上层依赖下层提供的能力完成业务
    *   抽象是多种场景的共性，具体实现依赖通用抽象
*   描述核心类（对象）与工程、包、源码仓库的关系
*   依赖结构最底层的类如果是工具类，其接口和实现需要剥离业务语义，在不同场景下复用
    【裁剪说明】不可裁剪，可以以修改点列表方式呈现

# 4. 系统流

【裁剪说明】不可裁剪。
【帮助1】对功能与属性质量需求的实现，功能一般是通过各模块之间的交互达到目的，本节所有的参与者或执行者一定是在软件结构章节中的组件。
【帮助2】完成一个业务，通常需要考虑：系统启动、正常业务、异常业务三个场景的系统流。
【帮助3】本次模板已裁剪“算法描述”章节，建议算法相关的内容放在本章中描述

## 4.1 流程1

### 1.1 业务描述

【帮助】当前流程的业务目标和需要主要的流程关键点、约束和限制

### 4.1.2 交互图

【帮助1】一般使用时序图、流程图、活动图来描述软件的交互过程。
【帮助2】描述主流程，不要过分细化异常分支处理流程。

### 4.1.3 补充说明

【帮助1】对于交互的补充说明，通常是一些异常分支。参考如下表格描述异常：

### 4.1.4 关键算法

【裁剪说明】可裁剪
【帮助1】交互图中无法详细描述的算法细节，在本章节进行详细描述
【帮助2】可以采用伪代码、文字、详细流程图等形式化的方式进行描述

# 5. 数据结构

【裁剪说明】如果没有新增和修订数据结构，本章节可裁剪。
【帮助1】定义新的数据结构的格式，以及对现有数据结构的扩展或修改。并说明数据的作用以及相互间的关系。
【帮助2】存储（POS）组专用：修改关键元数据时需要参考01 存储组持久化元数据管理规范.docx，并完成存储组元数据变更影响面评估表
【帮助3】其他组通用：涉及跨模块数据结构变更，需要完成（跨模块的）数据结构变更影响评估

# 6. 接口设计

【帮助1】典型故障案例

*   通常接口应当设计为请求应答模式，便于做时序控制，只有允许丢弃的消息，才设计为单向通知
    不同协议的接口，关注的字段信息可能存在差异，为了方便接口设计,模板分为两部分
    l 接口通用描述信息，每个接口必须包含该部分，不可裁剪
    l 接口详细描述信息，根据不同协议协议类型的接口选择对应的模板

### <1. http协议>

<接口描述信息>
接口名称\*
接口分组
接口功能规格\*
接口协议\*
接口版本号\*
接口兼容性
使用场景\*
业务限制\*
接口类型\*
接口性能指标
接口安全性\*
接口幂等性\*
接口可测试性
遗留问题
其他注意事项
<请求参数部分>
字段名
字段描述
是否必填
字段类型
默认值
取值范围
<响应参数>
字段名
字段描述
字段类型
取值范围

# 7. 最终用户接口

【帮助】描述最终用户如何使用本产品完成任务。定义用户接口命令，参数，屏幕格式，错误提示信息，以及屏幕快照例子等。也包括用户使用性能(如任务花费时间，成功率等)，安全性考虑，以及适当的命令和错误信息扩展。
对于用户界面上显示的CLI命令中的帮助文字，可以在这里描述。如果这里没有描述，也可以在“源代码”等合适的章节中描述。如果已经在其它的文档中描述，则给出该文档的说明或链接也就可以了。如果都没有描述，则默认采用与Cisco相同的帮助文字。
同时考虑对于使用产品有困难(如残疾人)的人员如何完成任务，特别是用了哪些辅助技术。
产品的外部硬件接口、指示灯、按钮等，也都是用户接口，应根据产品的软硬件接口文档的描述，说明这些外部接口在用户使用过程的功能表现。
【裁剪说明】如果特性需求说明书或者软件功能规格中已经详细描述，这里简单说明一下参见特性需求说明书或者软件功能规格就可以了；如果有细化，则细化的内容在这里描述。

# 8. 版本和编译考虑

## 8.1 版本编译

【裁剪说明】未引入新的组件，本章节可给予说明并裁剪
【帮助1】如果终端、客户端、桌管代理（OA）涉及OS、CPU架构的变化，需要设计怎么打包和编译，例如：MACOS需要线下编译
【帮助2】是否考虑了功能的编译配置，即该功能如何被编译系统编译； 该组件如果是独立发布的组件，组件升级和版本管理如何考虑？
【帮助3】本章节需要在设计同时考虑此功能需求涉及到（落地）的组件相关信息，包括但不限于组件环境的搭、编译打包策略以及依赖关系等。如果需求落地到一个全新组件，设计需要考虑从打包到安装的具体实现步骤/过程，侧重脚本逻辑。

# 9. 软件限制与约束

【帮助】描述已知的限制与约束，包括某个配置下不支持的功能特性，或者目前不支持的一些特性组合。如果有的话，需要描述与其他软件产品和OS间的依赖性。以及为了让使用产品有困难的人员能使用本产品，用的辅助技术有哪些限制和约束。
【裁剪说明】对使用产品有困难的人员能使用本产品的约束，有则描述，没有可以不用写。

# 10. 开发单元测试

【帮助】定义单元测试用例使用的方法，包括：
·定义单元测试通过的标准，通过后才能合并到版本主干开始项目的集成测试
·是否需要特定的测试设备
·与法律法规有关的测试也要考虑
<正文>
【裁剪说明】1．如果项目裁剪掉单元测试活动，本章不适用。

# 《Java 编码规范及最佳实践》

该文档主要包含 Java 编码规范及最佳实践的内容，包括规范分类、代码健壮性、高性能、安全性规范，异常处理和日志规范，代码可读性规范，通用工具类使用规范等，下面是按照要求将其转换为 Markdown 格式后的内容：

### 修订记录



| 日期           | 修订版本 | 修改者     | 修改描述                          |
| ------------ | ---- | ------- | ----------------------------- |
| 2024 - 5 - 8 | V1.0 | 原作者：郭京满 | 将已有编码规范导入飞书文档，方便后续编辑和修订       |
| 2024 - 5 - 8 | V1.9 | 李进      | 增加代码可读性、健壮性的等多个规范，移除了没用的可读性规范 |
| 2024 - 9 - 9 | V2.0 | 李进      | 根据评审意见进行补充修订                  |

### 规范分类



| 分类   | 说明                                                                           |
| ---- | ---------------------------------------------------------------------------- |
| 【强制】 | - 强制规范是必须遵循的规范 - 违反规范无法通过静态检查或人工代码审查 - 因违反强制规范引入的 BUG（含集成和内测），归类为编码阶段的低级 BUG |
| 【建议】 | - 建议规范通常是针对某个特定问题的最佳实践 - 没有更好的方案时，优先选择 - 如果有更好的方案，欢迎提出并讨论，也欢迎在工程中实践          |
| 【参考】 | - 参考规范是结合业界常见最佳实践给出的参考 - 不要求完全遵守                                             |

### 代码健壮性规范

**入参必须先校验再使用**

【强制】模块 API 方法入参使用注解声明校验规则。基本使用方式：[http://conf.ruijie.work/pages/viewpage.action?pageId=78002559](http://conf.ruijie.work/pages/viewpage.action?pageId=78002559)

【强制】模块内公共方法入参默认非空，使用 Assert 工具函数声明入参要求。

【强制】公共方法入参可以声明 @Nullable 注解，使用前需要判空。

【强制】方法入参或返回值为 Optional 类型时，不能声明 @Nullable 注解。

**调用公共方法后立即校验返回码 / 返回值**

【强制】返回值是 Optional 类型时，使用前必须判断是否存在。

【强制】返回值是集合类或数组时，使用前必须判断是否为空集合或空数组。

【强制】返回值允许为 NULL 时，使用前需判空。

【强制】执行 IO 操作（文件操作、网络通信）后，必须判断返回值。

**公共方法非必要不返回 NULL**

【强制】公共方法默认不返回 NULL，需要返回 NULL 时，需要在方法上声明 @Nullable 并提供注释说明。

【建议】公共方法返回单个对象时，使用 Optional 作为返回值。

【强制】根据 ID 查询领域对象的 API 方法，如果领域对象不存在，抛出 BusinessException。

【强制】方法返回值是集合类或数组时，返回空集合对象、空数组。

【强制】方法返回值是集合类或数组时，集合或数组内部元素不能为 NULL。

**数据库查询不返回 NULL**

【强制】使用 JPA 的 findById () 方法获取数据库 Entity 对象。

【强制】不允许使用 JPA 的 getOne () 方法获取数据库 Entity 对象。

【强制】JPA 自定义方法返回单条记录时，使用 Optional 作为返回值。

【强制】JPA 自定义 countBy ()、existsBy () 方法使用基本类型作为返回值。

**IO 对象使用时避免内存泄漏**

【强制】IO 对象必须在 finally 中调用 close () 方法。

**遍历数组 / 集合类时避免越界或并发修改异常**

【建议】优先使用 foreach、stream 遍历数组、集合。

【强制】使用索引下标获取集合、数组元素前，需要校验长度。

【强制】在需要对集合元素做变更时使用 Iterator 遍历。

**避免出现空指针异常**

【强制】包装类型必须显式转换为基本类型。

【强制】使用 Objects.equals () 方法比较对象一致性。

【强制】数组对象转 Stream 之前，必须做非空校验。

【强制】禁止级联调用超过两层。

**switch - case/if - else 必须有兜底处理**

【强制】switch 代码块的每个 case 都必须有 break，必须有兜底处理的 default 语句。

【强制】多分支 if - else 必须有兜底处理的 else（即使永远走不到，也要有）。

**避免使用浮点类型导致计算精度问题**

【强制】不允许使用浮点类型（float、double）做数学运算，优先使用整型或者使用 BigDecimal 代替。

【强制】磁盘、内存容量使用整形，需要呈现时进行转换。

【强制】不允许使用浮点类型作为 API 接口、数据库字段。

【建议】CPU 占用率、内存占用率、网络占用率、磁盘占用率等字段以百分比形式表示，可能有小数，建议后端给出原始值（分子和分母），由前端进行计算。

**避免过度使用包装类型**

【强制】数据库 Entity 对象、模块的领域数据对象（DTO 对象）的所有基本属性均使用包装类型。

【强制】模块 API 的入参和返回值，均使用包装类型。

【例外】以 exists、count 开头的函数，默认使用基本类型作为返回值。

【建议】参与判断和计算的临时变量，均使用基本类型。

**避免修改上层入参和下层返回值**

【强制】不修改集合类对象的返回值。

【强制】只有明确有 fill、put、convert 语义的函数可以修改入参内容。

**其他**

【强制】作为 HashMap 的 Key 的对象或者传入 HashSet 的对象需要同时复写 equals 和 hashcode 方法。

【强制】方法内部的局部变量不能覆盖或变更方法入参。

【建议】方法入参、局部变量默认标记为 final。

【强制】数据库事务边界内（tx 包）只能编写与数据库处理有关的逻辑。

【强制】包装类型必须使用 Objects.equals () 方法比较对象一致性，不能用 ==。

### 代码高性能规范

**提高代码执行性能的基本方法**

【强制】当多个判断同时存在时，先执行代价小的判断。

【强制】同样的数据库查询、RPC 查询在同一个模块的业务流中只做一次。

【建议】同一个模块由公共 API 关联的业务流中，对于同一个记录的数据库、RPC 查询只做一次。

**循环体中不做影响性能的操作**

【强制】不能在循环体内单条查询关联表的数据。

【强制】不能在循环体内单条执行 RPC 查询。

【强制】循环体内正向流程只能打印 DEBUG 级别的 LOG。

【强制】循环体内必须使用 StringBuilder 进行字符串拼接。

**集合类的高性能使用**

【强制】使用 Map.entry 进行 Map 遍历。

【强制】Collection 转数组时使用 toArray () 方法进行转换。

【强制】数组转 Collection 时使用 Arrays.asList () 方法进行转换。

**使用细粒度锁解决高并发场景下的同步问题**

【强制】不能使用 Guava Interners 或 String.interner () 执行细粒度的加锁。

【建议】使用 Guava Striped 实现基于用户 ID、会话 ID 等信息的细粒度加锁。

### 代码安全性规范

**并发场景保障全局数据的安全**

【强制】全局变量 / 单例对象属性必须使用并发安全的数据类型。

【强制】全局变量 / 单例对象属性变更时需要加锁。

【强制】使用乐观锁保障数据库更新的一致性。

【强制】使用 DateTimeFormatter 进行日期格式转换。

### 异常处理和日志规范

**异常处理规范**

【强制】同一个方法中 try 关键字不能嵌套。

【强制】try 代码块中的代码不能超过 20 行。

【强制】finally 语句中不能出现 return 关键字。

【强制】不允许 catch 特定的异常。

【强制】仅允许主动抛出 BusinessException，以及特定的运行时异常。

【强制】catch 异常后必须进行处理。

【建议】不需要每一层都处理 BusinessException。

【建议】根据异常类型进行分别 catch 和处理。

【强制】catch 语句中不能对异常做 instaneof 或强转。

**日志记录规范**

【强制】任何公有调用失败后，立即记录 LOG。

【强制】LOG 记录中不应当包含 i++ 之类对数据状态产生影响的语句。

【强制】LOG 记录中不应当包含 toJson ()、toString ()、getXXX () 之外的方法调用。

【强制】INFO 及以下级别的 LOG 记录，需要用 if 判断。

### 代码可读性规范

**源文件规范**

【强制】统一使用 UTF - 8 编码。

**命名规范**

【强制】包名、类名、方法名、变量名只能使用字母、数字和下划线。命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。

【强制】命名禁止使用拼音与英文混合、纯拼音、中文。

【强制】方法名、参数名、成员变量、局部变量都首字母小写，必须遵从驼峰形式。

【强制】变量名避免单字母形式命名，除非变量作用域非常小，如 for 循环里的变量。

【强制】数组定义中 \[] 必须放在变量名前面。

【强制】包名，必须全部小写，不使用下划线，名词用单数。

【强制】类名，必须大写字母开头，使用名词或名词短语，多个单词组成使用驼峰标识法，如 TimeZone。

【强制】测试类以 Test 结尾，如：UserTest。

【强制】测试方法名以 test 前缀，如：testXXX ()。

【强制】异常类以 Exception 结尾，如：NumberFormatException。

【强制】抽象类以 Abstract 开头，如：AbstractAccessTask。

【强制】如果使用到了设计模式，需要在类名中体现出具体模式。

【强制】领域模型相关命名全部大写，如 DTO、DAO 等。

【强制】接口名必须是名词或名词短语，也可以是形容词（通常是–able 的形式），另外接口不加 I 前缀，实现类以 Impl 结尾。

【强制】枚举成员名称需要全大写，单词间用下划线隔开。

【强制】方法名，必须使用动词或动词短语。

【强制】常量命名全部大写，且统一定义为 static final，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。

【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写 l 容易跟数字 1 混淆，造成误解。

【建议】布尔返回值的函数命名，以 is、has、can、should、need、exists 等前缀，如：isEmpty () hasSiblings ()。

【强制】以 is 开头的函数，仅用于判断状态，不允许执行修改数据状态的业务，例如：isEmpty ()，isConnected ()。

【强制】以 check、validate 开头的函数，仅用于数据校验，校验失败应当抛出 BusinessException。

**代码风格**

【强制】左大括号前不换行。

【强制】一行不超过 200 个字符。

【强制】方法与方法之间必须留一行空白行。

【强制】单个方法不应当超过 50 行。

【强制】单个 if/else/while/for 语句块不应当超过 20 行。

【强制】单个 lambda 匿名函数语句不超过 5 行。

【强制】不含空格的连续代码不应当超过 10 行，超过 10 行需要使用空行分隔。

【强制】运算符号左右各加一个空格。

【强制】左大括号前要有一个空格。

【强制】代码缩进用 4 个空格。

【强制】if - else，while，try - catch - finally、switch、case 语句，即使只有一行代码，也必须用 { } 括起来。

【强制】同一个方法中 if/for/while/switch 嵌套不能超过 2 层。

【强制】if/while/for 语句中的判断条件不能超过两个。

【强制】三目运算符中不能包含复杂语句。

【强制】每次声明一个变量。

**注释规范**

【强制】类、类属性、类方法的注释必须使用 /\**内容*/ 格式，不得使用 // 内容方式。

【强制】模块接口类、POJO 类、RPC 接口类必须添加类和方法注释，其他内部类无需添加类、方法注释。

【强制】方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释使用 /\* \*/ 注释。

【强制】没用的代码需要删除，不应当进行注释。

【强制】特殊注释标记使用，TODO  FIXME。

【强制】标记为 “Deprecated” 的接口，必须同时在注释中说明替代的方法和使用方法。

【强制】注释要说明 “为什么这么做”，而不是 “做了什么”。

【强制】不允许使用魔法数字（泛指不能自我描述的符号），必须命名成有意义的常量。

【强制】POJO 类中，setter 、getter 方法不能加入业务逻辑代码。

【强制】公共方法、抽象类的 abstract 方法参数不超过 6 个，公共构造函数、私有函数的参数数量不受限制。

### 通用工具类 / 工具函数使用规范

**通用工具类优先级定义**

第 1 优先级：SK - Java 封装的工具类：通常在`com.ruijie.rcos.sk``.base.util`包中，例如：`com.ruijie.rcos.sk``.base.util.StringUtils`。

第 2 优先级：JDK 自带的工具类：通常在`java.util`包中以 s 结尾，例如`java.util.Arrays`、`java.util.Collections`。

第 3 优先级：Spring 中自带的工具类：通常在`org.springframework.util`包中，例如`org.springframework.util.Assert`、`org.springframework.util.CollectionUtils`。

第 4 优先级：`Google Guava`工具类，例如：`com.google.common.collect.Lists`。

第 5 优先级：`apache commons lang`工具类，通常在`org.apache.commons.lang3`包中，例如：`org.apache.commons.lang3.ArrayUtils`。

**【强制】使用的工具类列表**

SK - Java：`com.ruijie.rcos.sk``.base.util`，StringUtils，字符串的大多数操作，包括十进制和十六进制互转、字符串判空、拼接、查找。

SK - Java：`com.ruijie.rcos.sk``.base.util`，CollectionUitls，集合类的常见操作，包括判空、查找、交集计算、并集计算。

JDK：java.util，Collections，集合类常见操作，包括排序、打乱、空集、线程安全的集合。

JDK：java.util，Arrays，数组常见操作，包括排序，查找。

JDK：java.util，Objects，对象的常见操作，包括判空、计算 hash 值。

Spring：org.springframework.util，Assert，断言校验的常见操作，包括判空、类型匹配。

apache：org.apache.commons.lang3，ArrayUtils，数组常见操作，包括判空、反转。

apache：org.apache.commons.lang3，BooleanUtils，Boolean 类常见操作，避免空指针。

**【建议】使用的工具类**

Guava：com.google.common.collect，Lists/Maps/Sets，List/Map/Set 对象的工厂方法，可以根据需要构造固定长度的集合类。

**【严禁】使用的工具类**

Spring：org.springframework.cglib.core.CollectionUtils。

log4j：org.apache.logging.log4j.core.util.ArrayUtils。

log4j：org.apache.logging.log4j.core.util.Assert。

netty：io.netty.util.internal.StringUtil。

junit：org.junit.Assert。

### SK - Java 使用规范

SK - JAVA

### 最佳实践

### 附录

**附录 1：复杂 try - with - resource 场景下的异常处理的坑**

被抑制的异常是指在 try - with - resources 语句中资源关闭操作导致的异常，可以通过 getSuppressed () 方法获取到。

其他在 try - with - resources 块中发生的异常（比如空指针异常）不会被归为被抑制异常，而是直接抛出并由外层的 catch 块来处理。

目前无法直接提供可下载的 Markdown 文件，你可以手动复制上述内容，新建一个文本文件，将内容粘贴进去后，把文件扩展名改为`.md`，即可得到 Markdown 格式文件。
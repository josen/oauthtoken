# Java 代码评审提示词（基于《云桌面可靠性 / 可用性设计指南》）

## 一、输入可靠性检查

### （一）API 控制与配置规范

**模块交互**：模块行为控制必须通过公共 API 实现，严格禁止直接修改私有数据存储（如配置文件、数据库），确保数据修改操作有且仅有一个合法入口。

**入参校验**：所有方法和函数的入参必须执行全面校验，包括非空、数字范围、字符串长度等基础校验，以及领域实体的存在性和状态合法性校验。

**校验实践**：业务逻辑执行前必须完成入参校验，校验失败时返回预定义错误码；对于仅用于呈现的不可控长度字符串，需限定最大输入长度并静默丢弃超出部分。

### （二）API 文档与工具辅助

**文档要求**：API 文档必须明确标注校验规则、前置条件及条件不满足时的行为说明，确保调用方清晰知晓参数约束。

**工具使用**：优先使用 SK-Java 框架提供的注解式校验（如`@NotNull`、`@Size`），结合静态检查工具（如 SonarQube）识别未校验的字段或属性。

## 二、依赖可靠性检查

### （一）进程内模块依赖

**返回码校验**：通过异常体系（Java 的`try-catch`）或显式返回值校验进程内模块调用结果，框架兜底处理通用返回码，业务强相关返回码需单独处理。

**静态检测**：借助 IDE 插件或静态分析工具，确保所有模块调用的返回码均被正确校验，避免遗漏关键逻辑分支。

### （二）进程间 RPC 通信

**幂等与超时**

**写操作 API**：必须定义超时时间（如服务端组件间 RPC 设为 3 秒）和唯一幂等 ID，发送方负责生成 ID、控制重传次数（建议 3 次）及间隔，接收方实现幂等检测并忽略重复请求。

**异步 API**：引入任务机制，定义任务 ID 并提供状态查询接口，接收方记录任务状态并设置有效期（5 分钟至 7 天）。

**乱序与过期处理**

**消息通知 API**：强制携带单调递增序列号，发送方确保序列号时序递增，接收方丢弃过时消息并按需执行补偿逻辑（如关键实体状态同步）。

**消息队列**：消息需包含过期时间戳，接收方入队前记录时间戳，出队时校验并丢弃超时消息，提升高压力场景处理效率。

**OS 命令与配置文件**

**命令执行**：依赖 OS 命令的功能需通过轮询机制检测执行结果（如网络参数设置、进程重启状态），确保命令生效后再推进业务。

**配置文件**：定期轮询配置文件内容，处理空白、缺失等异常，提供默认值应对配置未就绪场景，通过文件系统事件监听配置变更。

### （三）依赖影响与最终一致性

**弱依赖设计**：系统启动时避免强依赖外部组件（如数据库），未就绪时跳过关联业务；业务处理使用数据库事务保证一致性，中断后自动重连并重试。

**最终一致性**：服务间通信通过轮询 + 重试获取最终状态，定时任务清理无效数据；客户端首次连接服务端时强制同步最新状态，确保分布式系统状态收敛。

## 三、环境可靠性检查

### （一）进程与配置可靠性

**进程管理**

**自启动与健康检测**：基于不同平台（K8s、systemd、SK-C++）配置进程自启动和健康检查，诊断逻辑需验证业务处理能力（如登录接口可用性），首次启动和升级时延长检测时间。

**业务恢复**：简单业务记录任务中间状态，重启后继续执行或清理残留数据；复杂业务使用任务流框架（如 SK 任务流）实现`do/undo`逻辑，确保补偿操作支持幂等重试。

**配置文件**：采用追加写或多版本方案（如 SK-C++ 可靠配置组件）避免写入损坏，禁止在临时目录（如`/tmp`）存储关键配置，更新时通过临时文件过渡并原子性重命名。

### （二）网络与系统资源

**网络通信**

**连接策略**：TCP 连接设置合理超时（连接超时 10 秒，读超时 3 秒），处理粘包问题时定义报文边界符；弱网环境区分 IO 异常与业务异常，前者按需重试，后者立即反馈。

**框架复用**：Java 语言优先使用 SK 框架提供的 TCP 连接件，避免自行封装底层网络逻辑，确保重连、超时策略统一。

**系统时间**：定时任务和超时逻辑使用不受系统时间修改影响的单调时钟 API（如 Java 的`System.nanoTime()`），避免依赖墙上时钟导致的任务执行异常。

**磁盘操作**：文件读写前校验目录存在性和权限，写入前检测磁盘空间；使用 IO 异常处理封装工具（如 SK-Java 的`IoUtil`），统一处理读写错误并向上层反馈。

### （三）多实例与状态管理

**无状态设计**：多实例部署时服务节点禁止缓存业务状态，所有状态统一存储至分布式缓存或数据库，确保故障时节点可无缝替换。

**冗余策略**：关键服务采用热备或暖备模式，通过心跳机制（如 K8s 健康检查）实时监测实例状态，故障时自动切换并触发日志告警。

## 四、通用设计原则检查

### （一）故障检测

**健康监测**：实现进程级监控（内存、CPU、线程数）和业务级监控（如订单处理成功率），使用 Watchdog 机制或平台提供的监控工具（如 Prometheus），健康检测进程优先级需高于业务进程，资源消耗控制在 1% 以内。

**异常检测**：对外部输入进行校验和限流（如令牌桶算法），内部维护任务重试次数和失败阈值，依赖异常（如网络超时）触发熔断并记录详细日志。

### （二）故障恢复与预防

**恢复策略**

**重试与补偿**：网络操作设置合理重试间隔（如 10 秒）和次数（3 次），失败后执行补偿逻辑（如订单退款），避免数据不一致；复杂业务通过检查点（Checkpoint）回滚至最近一致状态。

**优雅降级**：非核心业务与核心业务隔离线程池，故障时优先保障核心流程，如丢弃非关键日志写入任务以避免阻塞主链路。

**预防措施**

**熔断机制**：分布式调用超时或失败时触发熔断，设置冷却时间避免级联故障，例如依赖服务失败率超过 50% 时自动熔断 5 分钟。

**故障预测**：结合监控指标（如 HTTP 500 错误率、队列堆积量）建立预测模型，提前识别内存泄漏、句柄泄漏等潜在风险并触发预警。

### （三）最佳实践落地

**网络协议**：设计通信协议时使用序列号而非时间戳进行顺序控制，TCP 报文需包含长度字段解决粘包问题，参考案例中的重试间隔（10 秒）和次数（3 次）配置。

**文件操作**：下载文件时校验 MD5 值，覆盖写入前创建临时文件；避免在易清理目录存储关键数据，参考案例中的配置文件更新流程（临时文件 + 重命名）。

**依赖处理**：生产者 - 消费者场景中，调用方（A）实现熔断，被调用方（B）实施限流（如令牌桶），故障时 A 立即反馈失败并记录 LOG，而非无限重试。

## 五、案例合规性检查

**网络通信**：确保 RPC 调用实现幂等 ID 和超时重传，消息通知携带序列号，TCP 连接配置符合案例中的超时参数（3 秒读超时，10 秒连接超时）。

**数据恢复**：关键业务逻辑包含数据残留清理机制，分布式事务场景使用事后补偿（如最终一致性队列），避免状态不一致。

**文件可靠性**：配置文件操作采用多版本或追加写，临时文件操作遵循 “写入 - 校验 - 重命名” 流程，禁止在`/tmp`目录存储持久化数据。

**Docker 健康检查**：使用平台提供的 Python 脚本而非`curl`探测服务可用性，确保容器化部署的健康检测合规。

## 评审总结

严格对照上述检查点进行代码评审，重点关注【强制】规范（如幂等 ID、入参校验）和案例最佳实践，确保代码在输入处理、依赖管理、环境适配及通用设计上符合可靠性 / 可用性要求。对违反项需评估影响并制定整改计划，优先修复可能导致单点故障或数据不一致的问题，保障系统在异常场景下的自愈能力和持续服务能力。